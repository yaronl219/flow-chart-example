{"version":3,"sources":["reportWebVitals.js","store/reducers/sidebarReducer.js","store/reducers/graphReducer.js","store/reducers/rootReducer.js","store/store.js","services/mapService.js","store/actions/graphActions.js","cmps/MapNode.jsx","cmps/BorderCmp.jsx","pages/MapContainer.jsx","cmps/SidebarContainer.jsx","cmps/NodeGenerator.jsx","cmps/ImportCmp.jsx","index.js"],"names":["reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","initialState","isSidebarOpen","graphData","selectedNodes","rootReducer","combineReducers","sidebarReducer","state","action","type","payload","graphReducer","console","log","composeEnhancers","window","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","store","createStore","applyMiddleware","thunk","_createMockData","numberOfEvents","numberOfColumns","vertices","i","_createMockVertice","columns","edges","_createMockEdge","key","mockEdge","rand","getRandomInt","col","shouldDiverge","data","graph","Vertices","Edges","chancesOfDivergence","from","to","id","min","max","Math","floor","random","mapService","getGraphData","a","nodeAmount","setGraphData","amount","dispatch","MapNode","connect","selected","useState","isPartOfSelectedVariant","setIsPartOfSelectedVariant","useEffect","isSelected","find","node","Id","style","borderRadius","height","width","border","display","alignItems","justifyContent","flexDirection","backgroundColor","position","BorderCmp","setHeight","length","_height","lowestNodePos","yPos","mapDispatchToProps","setSelectedNodes","MapContainer","displayMapData","setDisplayMapData","isLoading","setIsLoading","isError","setIsError","mapData","useRef","time","instance","displayBorderNode","current","Date","now","parseMapData","setLayoutAndRender","callback","setTimeout","requestAnimationFrame","xPos","forEach","x","y","nodeData","padding","connectable","draggable","isHidden","unshift","_displayMap","elements","direction","nodeWidth","nodeHeight","dagreGraph","dagre","graphlib","Graph","setDefaultEdgeLabel","isHorizontal","setGraph","rankdir","el","isNode","setNode","setEdge","source","target","layout","_elements","map","nodeWithPosition","targetPosition","sourcePosition","getLayoutedElements","startTime","_parsedMapData","graphRawData","Object","values","edge","edgeData","From","To","push","err","nodeTypes","special","onClick","toObject","margin","connectionLineType","onSelectionChange","variantNodes","onTraverse","getLastChild","outgoers","getOutgoers","firstParent","getFirstParent","incomers","getIncomers","incomerChildren","lastChild","traverseBranch","variant","getVariantEdges","onlyRenderVisibleElements","minZoom","onLoad","ev","SidebarContainer","NodeGenerator","amountOfNodes","setAmountOfNodes","value","onChange","isNaN","importGraphData","ImportCmp","text","setText","isValidJson","setIsValidJson","JSON","parse","disabled","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.51aad5ba.chunk.js","sourcesContent":["const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","/* eslint-disable import/no-anonymous-default-export */\nconst initialState = {\n    isSidebarOpen: true\n};\n\nexport default function(state = initialState, action = {}) {\n    switch (action.type) {\n        case 'SET_SIDEBAR_OPEN':\n            const {isSidebarOpen} = action.payload\n            return { ...state, isSidebarOpen };\n\n        default:\n            return state;\n    }\n}\n\n","/* eslint-disable import/no-anonymous-default-export */\nconst initialState = {\n    graphData: null,\n    selectedNodes: null\n};\n\nexport default function (state = initialState, action = {}) {\n    switch (action.type) {\n        case 'SET_GRAPH_DATA':\n            console.log('setting graph data')\n            const { graphData } = action.payload\n            return { ...state, graphData };\n\n        case 'SET_SELECTED_NODES':\n            const { selectedNodes } = action.payload\n            return { ...state, selectedNodes }\n        default:\n            return state;\n    }\n}\n\n","import { combineReducers } from 'redux';\nimport sidebarReducer from \"./sidebarReducer\";\nimport graphReducer from \"./graphReducer\";\n\nconst rootReducer = combineReducers({\n    sidebarReducer,\n    graphReducer\n})\n\nexport default rootReducer;\n","\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport thunk from 'redux-thunk';\nimport rootReducer from './reducers/rootReducer.js';\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\n\nexport const store = createStore(\n    rootReducer,\n    composeEnhancers(applyMiddleware(thunk))\n);\n","\nconst getGraphData = async (nodeAmount = 100) => {\n    return _createMockData(nodeAmount,3)\n}\n\nfunction _createMockData(numberOfEvents = 10, numberOfColumns = 1) {\n    const vertices = {}\n    for (let i = 0; i < numberOfEvents; i++) {\n        vertices[i] = _createMockVertice(i+1)\n    }\n\n    const columns = []\n\n    for (let i=0; i< numberOfColumns; i++) {\n        columns[i] = null\n    }\n\n    const edges = {}\n    let {key,mockEdge} = _createMockEdge(1,2)\n    edges[key] = mockEdge\n    for (let i = 1; i < numberOfEvents - 1; i++) {\n        // select random column\n        // debugger\n        const rand = getRandomInt(0,numberOfColumns)\n        const col = columns[rand] ? columns[rand] : i+1\n        let {key,mockEdge} = _createMockEdge(col,i+2)\n        edges[key] = mockEdge\n        if (shouldDiverge(10)) {\n            columns[rand] = i+1\n        }\n    }\n    console.log('finished creating data')\n    return {\n        data: [\n            {\n                graph: {\n                    Vertices: vertices,\n                    Edges: edges\n                }\n            }\n        ]\n    }\n}\n\nfunction shouldDiverge(chancesOfDivergence) {\n    \n    const chance = getRandomInt(0,100)\n    if (chance >= chancesOfDivergence) return true\n    return false\n}\n\nfunction _createMockEdge(from, to) {\n    const key = `<${from},${to}>`\n    const mockEdge = {\n        \"Id\": key,\n        \"From\": {\n            \"Id\": `${from}`\n        },\n        \"To\": {\n            \"Id\": `${to}`\n        }\n    }\n\n    return {key, mockEdge}\n}\n\nfunction _createMockVertice(id) {\n    return {\n        \"Id\": `${id}`,\n        \"Properties\": {\n\n        },\n        \"Type\": getRandomInt(1, 15),\n        \"WindowID\": 4,\n    }\n}\n\nfunction getRandomInt(min, max) {\n    return Math.floor(Math.random() * max) + min\n}\nexport const mapService = {\n    getGraphData\n}\n","import { mapService } from \"../../services/mapService\"\n\nexport function setGraphData(amount) {\n    return async dispatch => {\n        const graphData = await mapService.getGraphData(amount)\n        dispatch({type: 'SET_GRAPH_DATA', payload: {graphData}})\n    }\n}\n\nexport function importGraphData(graphData) {\n    return dispatch => {\n        dispatch({type: 'SET_GRAPH_DATA', payload: {graphData}})\n    }\n}\nexport function setSelectedNodes(selectedNodes) {\n    return dispatch => {\n        dispatch({type: 'SET_SELECTED_NODES', payload: {selectedNodes}})\n    }\n}\n","import React, { useEffect, useState } from 'react'\nimport { Handle } from 'react-flow-renderer'\nimport { connect } from 'react-redux'\n\nfunction _MapNode({selectedNodes, data, selected}) {\n\n    const [isPartOfSelectedVariant, setIsPartOfSelectedVariant] = useState(false)\n\n    useEffect(() => {\n        if (!selectedNodes) return setIsPartOfSelectedVariant(false)\n        const isSelected = !!selectedNodes.find(node => node.id === data.Id)\n        setIsPartOfSelectedVariant(isSelected)\n    }, [selectedNodes, data.Id])\n\n    return (\n        <div style={{ borderRadius: '50%', height: 50, width: 50, border: '1px solid black', display: 'flex', alignItems: 'center', justifyContent: 'center', flexDirection: 'column', backgroundColor:'white' }}>\n            <Handle type=\"source\" position=\"bottom\" />\n            <div>{data.Id}</div>\n            <div>{selected && 'selected'}</div>\n            <div>{isPartOfSelectedVariant && 'variant'}</div>\n            <Handle type=\"target\" position=\"top\" />\n        </div>\n    )\n}\n\nconst mapStateToProps = state => {\n    const { selectedNodes } = state.graphReducer\n    return {\n        selectedNodes\n    };\n};\n\nconst mapDispatchToProps = {\n    \n}\n\nexport const MapNode = connect(mapStateToProps, mapDispatchToProps)(_MapNode)\n","import React, { useState, useEffect } from 'react'\nimport { connect } from 'react-redux'\nimport { Handle } from 'react-flow-renderer'\n\nfunction _BorderCmp({ selectedNodes, data }) {\n    \n    const [height, setHeight] = useState(0)\n    \n    useEffect(() => {\n        if (!selectedNodes || !selectedNodes.length) return setHeight(0)\n    }, [selectedNodes])\n\n    useEffect(() => {\n        const _height = data.lowestNodePos + 50 + 25 - data.yPos\n        setHeight(_height)\n    }, [data])\n\n    if (!selectedNodes || !selectedNodes.length) return <div></div>\n    return (\n        <div style={{ height, width: data.width, border: '1px solid black', backgroundColor: 'yellow', borderRadius: '3px' }}>\n            <Handle type=\"source\" position=\"bottom\" />\n        </div>\n    )\n}\n\nconst mapStateToProps = state => {\n    const { selectedNodes } = state.graphReducer\n    return {\n        selectedNodes\n    };\n};\n\nconst mapDispatchToProps = {\n\n}\nexport const BorderCmp = connect(mapStateToProps, mapDispatchToProps)(_BorderCmp);\n","import React, { useEffect, useRef, useState } from 'react'\nimport { connect } from 'react-redux';\nimport { setGraphData, setSelectedNodes } from '../store/actions/graphActions'\nimport dagre from 'dagre'\nimport ReactFlow, { isNode, Background, getIncomers, getOutgoers } from 'react-flow-renderer';\nimport { MapNode } from '../cmps/MapNode';\nimport { BorderCmp } from '../cmps/BorderCmp';\n\nfunction _MapContainer({ setGraphData, graphData, setSelectedNodes, selectedNodes }) {\n\n    const [displayMapData, setDisplayMapData] = useState(null)\n    const [isLoading, setIsLoading] = useState(true)\n    const [isError, setIsError] = useState(false)\n\n    let mapData = useRef(null)\n    let time = useRef(0)\n    let instance = useRef(null)\n\n    useEffect(() => {\n        setGraphData()\n    }, [])\n\n    useEffect(() => {\n        displayBorderNode()\n    }, [selectedNodes])\n\n    useEffect(() => {\n        setIsLoading(true)\n        time.current = Date.now()\n        parseMapData()\n        setLayoutAndRender()\n    }, [graphData])\n\n    useEffect(() => {\n        if (!time.current) return\n        onNextFrame(() => {\n            console.log('time from getting data', Date.now() - time.current)\n            setIsLoading(false)\n        })\n    })\n\n    const onSelectNode = (a) => {\n        if (!a) {\n            setSelectedNodes(null)\n            return\n        }\n        const node = a[0]\n        getVariantEdges(node)\n    }\n\n    const displayBorderNode = () => {\n        if (!selectedNodes) return\n\n        const padding = 25\n        const width = 75\n        let lowestNodePos\n        let xPos\n        let yPos\n        selectedNodes.forEach(node => {\n            if (!xPos || xPos > node.position.x) xPos = node.position.x\n            if (!yPos || yPos > node.position.y) yPos = node.position.y\n            if (!lowestNodePos || lowestNodePos < node.position.y) lowestNodePos = node.position.y\n        })\n        let data\n        if (selectedNodes) {\n            data = [...mapData.current]\n\n            const nodeData = {\n                type: 'border',\n                id: 'border',\n                data: {xPos, yPos, width, lowestNodePos},\n                position: { x: xPos - (padding / 2), y: yPos - (padding / 2)},\n                connectable: false,\n                draggable: false,\n                isHidden: !(selectedNodes && selectedNodes.length)\n            }\n\n            data.unshift(nodeData)\n        }\n\n\n\n\n        setLayoutAndRender(data)\n    }\n\n    const traverseBranch = (node, onTraverse = () => { }) => {\n        // traverses a branch until it diverges\n\n        const getFirstParent = (node) => {\n            const incomers = getIncomers(node, displayMapData)\n            if (!incomers.length) return node\n            const incomerChildren = getOutgoers(incomers[0], displayMapData)\n            onTraverse(node)\n            if (incomerChildren.length > 1) return node\n            return getFirstParent(incomers[0])\n        }\n\n        const getLastChild = (node) => {\n            const outgoers = getOutgoers(node, displayMapData)\n            onTraverse(node)\n            if (outgoers.length === 1) return getLastChild(outgoers[0])\n            return node\n        }\n\n        const firstParent = getFirstParent(node)\n        const lastChild = getLastChild(node)\n\n        return { firstParent, lastChild }\n    }\n\n    function getVariantEdges(node) {\n        const variantNodes = []\n        const addNodeToVariant = (node) => {\n            const isNodeExist = !!variantNodes.find(variant => variant.id === node.id)\n            if (isNodeExist) return\n            variantNodes.push(node)\n        }\n        traverseBranch(node, addNodeToVariant)\n        setSelectedNodes(variantNodes)\n    }\n    function onNextFrame(callback) {\n        // called once the render is completed\n        setTimeout(function () {\n            requestAnimationFrame(callback)\n        })\n    }\n\n    const getLayoutedElements = (elements, direction = 'TB', nodeWidth, nodeHeight) => {\n        const dagreGraph = new dagre.graphlib.Graph();\n        dagreGraph.setDefaultEdgeLabel(() => ({}));\n\n        const isHorizontal = direction === 'LR';\n        dagreGraph.setGraph({ rankdir: direction });\n\n        elements.forEach((el) => {\n            if (isNode(el)) {\n                dagreGraph.setNode(el.id, { width: nodeWidth, height: nodeHeight });\n            } else {\n                dagreGraph.setEdge(el.source, el.target);\n            }\n        });\n\n        dagre.layout(dagreGraph);\n        const _elements = elements.map((el) => {\n            if (isNode(el)) {\n                const nodeWithPosition = dagreGraph.node(el.id);\n                el.targetPosition = isHorizontal ? 'left' : 'top';\n                el.sourcePosition = isHorizontal ? 'right' : 'bottom';\n\n                // unfortunately we need this little hack to pass a slightly different position\n                // to notify react flow about the change. Moreover we are shifting the dagre node position\n                // (anchor=center center) to the top left so it matches the react flow node anchor point (top left).\n                el.position = {\n                    x: nodeWithPosition.x - nodeWidth / 2 + Math.random() / 1000,\n                    y: nodeWithPosition.y - nodeHeight / 2,\n                };\n            }\n\n            return el;\n        });\n        console.log('built graph', Date.now() - time.current)\n\n        return _elements\n    };\n\n    const setLayoutAndRender = (data) => {\n        if (data) return setDisplayMapData(data)\n        data = mapData.current\n        if (!data) return\n        const _displayMap = getLayoutedElements(data, 'TB', 50, 50)\n        setDisplayMapData(_displayMap)\n    }\n\n    const onFinishLoadingMap = (ev) => {\n        instance.current = ev\n        console.log(Date.now() - time.current)\n    }\n\n    const onClickToObject = () => {\n        console.log(instance.current.toObject())\n    }\n\n    const parseMapData = () => {\n        const startTime = Date.now()\n        setIsError(false)\n        try {\n            if (!graphData) return\n            const position = { x: 0, y: 0 };\n            const _parsedMapData = []\n            const graphRawData = graphData.data[0].graph\n            const edgeType = 'brazier';\n\n            Object.values(graphRawData.Edges).forEach(edge => {\n                const edgeData = {\n                    id: edge.Id,\n                    source: edge.From.Id,\n                    target: edge.To.Id,\n                    type: edgeType\n                }\n                _parsedMapData.push(edgeData)\n            })\n\n            Object.values(graphRawData.Vertices).forEach(node => {\n                const nodeData = {\n                    type: 'special',\n                    id: node.Id,\n                    data: node,\n                    position\n                }\n                _parsedMapData.push(nodeData)\n            })\n\n            mapData.current = _parsedMapData\n            console.log('parsing the data took', Date.now() - startTime)\n        } catch (err) {\n            setIsError(true)\n\n        }\n    }\n\n    const nodeTypes = {\n        special: MapNode,\n        border: BorderCmp\n    };\n\n    if (isError) return <div>Error parsing the data</div>\n    if (isLoading) return <div>Loading...</div>\n    if (!displayMapData) return <div />\n\n    return (\n        <div >\n            <div style={{ width: '100%', display: 'flex', justifyContent: 'center' }}>\n                <button onClick={() => setLayoutAndRender(null)}>Reorganize</button>\n                <button onClick={onClickToObject}>to object</button>\n            </div>\n            <div style={{ height: '800px', width: '1600px', margin: '1rem', border: '1px solid black', borderRadius: '0.25rem', padding: '1px' }}>\n                <ReactFlow\n                    elements={displayMapData}\n                    nodeTypes={nodeTypes}\n                    connectionLineType=\"smoothstep\"\n                    onSelectionChange={onSelectNode}\n                    onlyRenderVisibleElements={true}\n                    minZoom={0.2}\n                    onLoad={onFinishLoadingMap}\n                >\n                </ReactFlow>\n            </div>\n        </div>\n    )\n}\n\nconst mapStateToProps = state => {\n    const { graphData, selectedNodes } = state.graphReducer\n    return {\n        graphData,\n        selectedNodes\n    };\n};\n\nconst mapDispatchToProps = {\n    setGraphData,\n    setSelectedNodes\n}\n\nexport const MapContainer = connect(mapStateToProps, mapDispatchToProps)(_MapContainer);\n","import React from 'react'\nimport { connect } from 'react-redux'\n\n\nfunction _SidebarContainer({isSidebarOpen}) {\n    return (\n        <div>\n        </div>\n    )\n}\n\nconst mapStateToProps = state => {\n    const {isSidebarOpen} = state.sidebarReducer\n    return {\n        isSidebarOpen\n    };\n};\n\nconst mapDispatchToProps = {\n\n}\n\nexport const SidebarContainer = connect(mapStateToProps,mapDispatchToProps)(_SidebarContainer);\n","import React, { useState } from 'react'\nimport { connect } from 'react-redux';\nimport { setGraphData } from '../store/actions/graphActions'\n\nfunction _NodeGenerator({setGraphData}) {\n    const [amountOfNodes, setAmountOfNodes] = useState(100)\n\n    const onChangeAmountOfNodes = (ev) => {\n        const amount = +ev.target.value\n        if (isNaN(amount)) return\n        setAmountOfNodes(amount)\n    }\n\n\n    return (\n        <div style={{display:'flex', flexDirection:'column'}}>\n            <h3>Generate random nodes</h3>\n            <input value={amountOfNodes} onChange={onChangeAmountOfNodes} />\n            <button onClick={() => setGraphData(amountOfNodes)}>Generate</button>\n        </div>\n    )\n}\n\nconst mapStateToProps = state => {\n    return {}\n};\n\nconst mapDispatchToProps = {\n    setGraphData,\n}\n\nexport const NodeGenerator = connect(mapStateToProps, mapDispatchToProps)(_NodeGenerator);\n","import React, { useState, useEffect } from 'react'\nimport { connect } from 'react-redux';\nimport { importGraphData } from '../store/actions/graphActions'\n\nfunction _ImportCmp({importGraphData}) {\n\n    const [text, setText] = useState('')\n    const [isValidJson, setIsValidJson] = useState(false)\n\n    const onChangeTextField = (ev) => {\n        const {value} = ev.target\n        setText(value)\n    }\n\n    useEffect(() => {\n        if (!text) return\n        try {\n            JSON.parse(text)\n            setIsValidJson(true)\n        } catch (err) {\n            setIsValidJson(false)\n        }\n    }, [text])\n\n    const onSetGraphFromJson = () => {\n        try {\n            const graphData = JSON.parse(text)\n            importGraphData(graphData)\n        } catch (err) {\n            console.log(err)\n            setIsValidJson(false)\n        }\n    }\n\n    return (\n        <div style={{display:'flex', flexDirection:'column'}}>\n            <h3>Import from JSON</h3>\n            <input value={text} onChange={onChangeTextField} />\n            <button onClick={onSetGraphFromJson} disabled={!(text && isValidJson) }>Set graph from JSON</button>\n        </div>\n    )\n}\n\nconst mapStateToProps = state => {\n    return {}\n};\n\nconst mapDispatchToProps = {\n    importGraphData,\n}\n\nexport const ImportCmp = connect(mapStateToProps, mapDispatchToProps)(_ImportCmp);\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport reportWebVitals from './reportWebVitals';\nimport {store} from './store/store'\nimport {Provider} from \"react-redux\";\nimport { MapContainer } from './pages/MapContainer';\nimport { SidebarContainer } from './cmps/SidebarContainer';\nimport { NodeGenerator } from './cmps/NodeGenerator';\nimport { ImportCmp } from './cmps/ImportCmp';\n\nReactDOM.render(\n  <Provider store={store}>\n    <header style={{display:'flex', justifyContent: 'space-around', alignItems:'center'}}>\n      <NodeGenerator />\n      <ImportCmp />\n      </header>\n      <MapContainer />\n      <SidebarContainer />\n    </Provider>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}